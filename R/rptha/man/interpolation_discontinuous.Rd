% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unstructured_interpolation.R
\name{interpolation_discontinuous}
\alias{interpolation_discontinuous}
\title{Discontinuous interpolation function}
\usage{
interpolation_discontinuous(
  xy,
  vals,
  newPts,
  category_function = function(xy) {     xy[, 1] * 0 + 1 },
  interpolator = triangular_interpolation,
  ...
)
}
\arguments{
\item{xy}{Matrix with x-y locations with known values, from which we wish interpolate}

\item{vals}{Matrix with the same number of rows as xy, and 1 or more columns, giving the values at xy}

\item{newPts}{Matrix with x-y locations where we would like to compute interpolated values}

\item{category_function}{Function taking xy or newPts matrix as an input, which returns a value
for each point. Each unique function value is associated with a group}

\item{interpolator}{Function taking xy, vals, newPts, ..., which is applied to each group of points}

\item{...}{Further arguments to interpolator}
}
\value{
A matrix with the same number of rows as newPts, and the same number of columns as vals, giving
interpolated values at newPts
}
\description{
For typical interpolation, we are given some xy points and an associated
matrix of values, and want to interpolate corresponding values at new points.
This function is similar except we also provide a 'category function' which
returns a unique value for each 'category' or 'group' of points given their
x-y coordinates.  The interpolation is performed separately on each category
The main reason to do this is if there are discontinuities in the data, and 
you don't wish the interpolation to cross these boundaries.
}
\examples{
  xy = matrix(runif(200), ncol=2)
  vals = (xy[,1] > 0.5) + (xy[,2] > 0.5)

  newPts = matrix(runif(3000), ncol=2)
  # Make 4 categories
  category_function<-function(xy){
      (xy[,1] > 0.5) + 10*(xy[,2] > 0.5)
  }

  newPts_vals = interpolation_discontinuous(xy, vals, newPts, category_function)

  theoretical_answer = (newPts[,1] > 0.5) + (newPts[,2] > 0.5)
  stopifnot(all(theoretical_answer == newPts_vals))

}
