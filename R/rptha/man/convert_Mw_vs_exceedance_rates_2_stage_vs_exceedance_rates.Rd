% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_stage_vs_rate_curve_fast.R
\name{convert_Mw_vs_exceedance_rates_2_stage_vs_exceedance_rates}
\alias{convert_Mw_vs_exceedance_rates_2_stage_vs_exceedance_rates}
\title{Get a set of stage-vs-exceedance-rate curves (one for each magnitude-exceedance rate logic-tree branch)}
\usage{
convert_Mw_vs_exceedance_rates_2_stage_vs_exceedance_rates(
  logic_tree_rate_curve_Mw,
  logic_tree_rate_curves_exceedance_rate,
  event_Mw,
  event_conditional_probability,
  event_max_stage,
  output_stages,
  use_Fortran = TRUE,
  drop_small_events = FALSE
)
}
\arguments{
\item{logic_tree_rate_curve_Mw}{vector with magnitudes at which the 
logic-tree exceedance-rate curves are tabulated}

\item{logic_tree_rate_curves_exceedance_rate}{matrix with one row per 
logic-tree branch, and one column per logic_tree_rate_curve_Mw, giving the 
exceedance rate at each magnitude.}

\item{event_Mw}{vector of magnitudes for each event. These should be drawn 
from an evenly spaced set (e.g. 7.2, 7.3, ... 9.8)}

\item{event_conditional_probability}{vector with the same length as 
event_Mw giving the conditional probability that the event occurs, given 
that an event with the same Mw occurred.}

\item{event_max_stage}{The max stage for each event at the site of interest}

\item{output_stages}{the stages at which we tabulate outputs. They must be 
sorted from low-to-high}

\item{use_Fortran}{logical if TRUE do the heavy computations using compiled 
Fortran code. Otherwise do them in R (slower)}

\item{drop_small_events}{logical if TRUE, then remove events with 
(event_max_stage < min(output_stages)) AND with 
(event_conditional_probability = 0). Beware the latter constraint leads to 
changes in results (typically slight), because it implies a different
interpolation of the stage-vs-exceedance-rate curve derived from scenarios.
For instance, suppose the scenarios have: stages = c(1, 2, 3, 4, 5);
individual_rates = c(1, 0, 0, 1, 0). Then for the given scenario stages, we
have exceedance_rates = c(2, 1, 1, 1, 0) (here keeping the
zero-conditional-probability events). Then approx(stages, exceedance_rates,
xout=2.5)$y == 1. However, if we dropped the 'zero conditional probability'
events before interpolating, then we would get stages = c(1, 4),
exceedance_rates = c(2, 1), and so approx(c(1, 4), c(2, 1), xout=2.5)$y ==
1.5. Note this is larger (in general) than the result obtained by keeping
'zero conditional probability' events. The latter makes the interpolation
more like a step function.}
}
\value{
A matrix with one row for each logic-tree branch, and one column for
each output-stage, giving the exceedance-rates
}
\description{
Suppose we have a source zone containing a set of Mw-vs-exceedance rate
curves, and a corresponding set of events, each of which lead to a given
max-stage at a particular site. This routine computes a
stage-vs-exceedance-rate curve for each Mw-vs-exceedance rate curve.
}
\examples{

logic_tree_rate_curve_Mw = seq(7.2, 9.8, by=0.1)
# 20 logic-tree branches
NB = 20
logic_tree_rate_curves_exceedance_rate = matrix(0, nrow=NB, ncol=length(logic_tree_rate_curve_Mw))
bs = seq(0.7, 1.3, len=NB)
for(i in 1:NB){
    logic_tree_rate_curves_exceedance_rate[i,] = 10**(-bs[i]*(logic_tree_rate_curve_Mw - 7))
}

# Set of events -- 30 per magnitude
N_per_mag = 30
NE = N_per_mag*length(logic_tree_rate_curve_Mw)
event_Mw = rep(logic_tree_rate_curve_Mw, times=N_per_mag)
event_conditional_probability = rep(1/N_per_mag, length(event_Mw))
# Make up some max-stage values
event_max_stage = runif(length(event_Mw)) - 0.5 + 0.5*(event_Mw - 6)
# Make some max-stage values small, to help test drop_small_events
event_max_stage[1:3] = 0
# Make output_stages -- notice the minimum is > 0
N_output_stages = 100
output_stages = 10**seq(-2, 1.5, len=N_output_stages)

# Typical version
results = convert_Mw_vs_exceedance_rates_2_stage_vs_exceedance_rates(
    logic_tree_rate_curve_Mw,
    logic_tree_rate_curves_exceedance_rate,
    event_Mw,
    event_conditional_probability,
    event_max_stage,
    output_stages)

## This is in pure R code
results_R = convert_Mw_vs_exceedance_rates_2_stage_vs_exceedance_rates(
    logic_tree_rate_curve_Mw,
    logic_tree_rate_curves_exceedance_rate,
    event_Mw,
    event_conditional_probability,
    event_max_stage,
    output_stages,
    use_Fortran=FALSE)

# They should be 'the same' up to floating point reordering
## Small absolute error
stopifnot(all(abs(results - results_R) < 1.0e-13))
## Small relative error (1e-20 zero divide protection)
stopifnot(all( ((results + 1e-20)/(results_R+1e-20) - 1) < 1.0e-12))

results_F2 = convert_Mw_vs_exceedance_rates_2_stage_vs_exceedance_rates(
    logic_tree_rate_curve_Mw,
    logic_tree_rate_curves_exceedance_rate,
    event_Mw,
    event_conditional_probability,
    event_max_stage,
    output_stages, 
    drop_small_events=TRUE)

# Should be the same as the first example
## Zero absolute error
stopifnot(all(abs(results - results_F2) == 0))
## Zero relative error (1e-20 zero divide protection)
stopifnot(all( ((results + 1e-20)/(results_F2+1e-20) - 1) == 0))
}
