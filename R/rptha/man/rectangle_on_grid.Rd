% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sffm_fit_simulate_earthquake.R
\name{rectangle_on_grid}
\alias{rectangle_on_grid}
\title{Make a rectangle with a given size and target location on a grid}
\usage{
rectangle_on_grid(
  grid_LW,
  num_LW,
  target_centre,
  randomly_vary_around_target_centre = FALSE
)
}
\arguments{
\item{grid_LW}{vector of length 2 giving the number of rows, columns on the
2D grid}

\item{num_LW}{vector of length 2 giving the desired number of rows,columns
on the rectangular sub-region}

\item{target_centre}{vector of length 2 giving the row,column indices on the
2D grid where we would like the centre of the sub-region to be.}

\item{randomly_vary_around_target_centre}{logical. If TRUE, then randomly
vary the output locations with the target_centre inside the rupture. If
FALSE, then try to make the target_centre be the centre of the rupture.}
}
\value{
integer vector of length 4. The first 2 entries are the min/max row
indices of the sub-region. The 3rd and 4th entries are the min/max column
indices of the sub-region.
}
\description{
Suppose we have a 2D grid (i.e. a logically rectangular set of cells),
and would like to define a rectangular sub-region consisting of L, W cells
with a given target x,y centre location. This problem arises when trying to define
regions of non-zero slip over unit sources for synthetic finite fault models. 
In many situations this is straightforward, but in some situations it is
ambiguous (e.g. if L and/or W is even, then no single grid cell is in the
'centre'), or impossible (e.g. if a given target centre is too close to the
grid boundaries, it  may be impossible to make a rectangle with L/W having the target_centre).
This code solves the problem, taking care of the ambiguous situations (with randomness)
and the impossible situations (by putting the centre somewhere else), in a manner
which seems satisfactory for synthetic finite fault model simulation.
}
\examples{
#
# Simple test case with deterministic answer
# 

v1 = rectangle_on_grid(c(4, 10), c(3, 3), c(2, 5))
stopifnot(all(v1 == c(1, 3, 4, 6)))

# Push a boundary
v1 = rectangle_on_grid(c(4, 10), c(3, 3), c(1, 5))
stopifnot(all(v1 == c(1, 3, 4, 6)))

# Push two boundaries
v1 = rectangle_on_grid(c(4, 10), c(3, 3), c(1, 1))
stopifnot(all(v1 == c(1, 3, 1, 3)))

v1 = rectangle_on_grid(c(4, 10), c(3, 3), c(4, 10))
stopifnot(all(v1 == c(2, 4, 8, 10)))

#
#  Case with non-deterministic answer
#
v1 = rectangle_on_grid(c(4, 10), c(2, 2), c(2, 5))
stopifnot(v1[2]-v1[1]+1 == 2)
stopifnot(v1[4]-v1[3]+1 == 2)

stopifnot(v1[1]\%in\%c(1,2))
stopifnot(v1[3]\%in\%c(4,5))

# Deterministic because of the boundary
v1 = rectangle_on_grid(c(4, 10), c(2, 3), c(1, 5))
stopifnot(v1[2]-v1[1]+1 == 2)
stopifnot(v1[4]-v1[3]+1 == 3)

stopifnot(v1[1]\%in\%c(1))
stopifnot(v1[3]\%in\%c(4))

# Overly large rupture because of the boundary
v1 = rectangle_on_grid(c(4, 10), c(5, 3), c(1, 5))
stopifnot(v1[4]-v1[3]+1 == 3)

stopifnot(v1[1:2] == c(1,4))
stopifnot(v1[3]\%in\%c(4))

print('PASS')

}
