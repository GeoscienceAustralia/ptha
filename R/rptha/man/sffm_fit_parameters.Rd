% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_simulate_earthquake.R
\name{sffm_fit_parameters}
\alias{sffm_fit_parameters}
\title{Fit SFFM parameters}
\usage{
sffm_fit_parameters(m1, default_seed = 1, NumRandSf = 400,
  sffm_pars = .sffm_default_model_parameters,
  reg_par_start = c(2/dim(m1)[1], 2/dim(m1)[2]))
}
\arguments{
\item{m1}{matrix or RasterLayer with slip values}

\item{default_seed}{integer. Force the random seed value to this, in order
to make the fit reproducible}

\item{NumRandSf}{integer. number of synthetic slip simulations to use in
goodness-of-fit computation}

\item{sffm_pars}{list containing parameters passed to \code{sffm_simulate}. See
\code{?sffm_simulate} and \code{?sffm_get_default_model_pars} for more info.}

\item{reg_par_start}{vector of starting values for parameters \code{reg_par} in
\code{sffm_pars$spectral_amplitude_fun} which are optimized by the current
function. See \code{?sffm_simulate} and \code{?sffm_get_default_model_pars}
for more info.}
}
\value{
an object from 'optim' with the fit
}
\description{
Function to compute the optimal reg_par parameters for the stochastic slip
model. Uses the stochastic optimization method of  Davies et al. (2015)
}
\examples{

# Make a random slip model with known parameters, for testing the fit
tg_mat = matrix(0, nrow=8, ncol=12)
tg_mat[3,5] = 1 # Fix peak slip location
xs = seq(0, 120, len=ncol(tg_mat)) # x-coordinates of tg_mat
ys = seq(0, 50, len=nrow(tg_mat)) # y-coordinates of tg_mat
dx = xs[2] - xs[1]
dy = ys[2] - ys[1]
# Make numerical corner wavenumbers c(kcxN, kcyN), corresponding to physical
# corner wavenumbers 1/50, 1/20
reg_par = c(1/50 * dx, 1/20 * dy) 
# Make simulation reproducible 
set.seed(1)
random_slip_mat = sffm_simulate(reg_par, tg_mat)

# Now try to back-estimate the reg_par parameters for random_slip_mat, using
# the stochastic optimization method
fitted_sffm_par = sffm_fit_parameters(random_slip_mat)
# Check we are within 20\% of the correct value (this will not always be true, but
# is for this case)
stopifnot(abs(reg_par - fitted_sffm_par$par)/reg_par < 0.2)

# The fit relies on stochastic simulations, so we get slightly different fits
# using different 'default_seed' values
fitted_sffm_parB = sffm_fit_parameters(random_slip_mat, default_seed=2)
stopifnot(abs(fitted_sffm_parB$par - fitted_sffm_par$par)/fitted_sffm_par$par < 0.05)

# #
# # Example of a more comprehensive test of the fitting algorithm.
# #
# # Test the fitting algorithm with simulation (run in parallel, since it can
# # take some time).
# # Idea: Generate many sffm with known kcx/kcy values, and then estimate the
# # latter values with sffm_fit_parameters. Ideally all fitted values would
# # equal the known values. In practice the fits are only approximate, and
# # we graphically illustrate this below 
# #
# library(parallel)
# nfits = 48 # Number of fits
# # Spread work over a number of shared memory cores -- my machine has 12,
# # and the following code takes a few minutes
# mc_cores = detectCores() 
# RNGkind("L'Ecuyer-CMRG") # ensure parallel random number generation
# random_slips = mclapply(1:nfits, f<-function(x) sffm_simulate(reg_par, tg_mat), 
#     mc.cores = mc_cores)
# random_slip_fits = mclapply(random_slips, f<-function(x) sffm_fit_parameters(x), 
#     mc.cores = mc_cores)
# 
# # Convert all the fitted parameters to a 2 column matrix
# all_fitted_par = matrix( unlist(lapply(random_slip_fits, f<-function(x) x$par)), 
#     ncol=2, byrow=TRUE)
# par(mfrow=c(1,2))
# hist(all_fitted_par[,1] / dx, main = 'Fitted kcx')
# abline(v=reg_par[1] / dx, col='red')
# hist(all_fitted_par[,2] / dy, main = 'Fitted kcy')
# abline(v=reg_par[2] / dy, col='red')

}
\references{
Davies et al. (2015), 
Tsunami inundation from heterogeneous earthquake slip distributions:
Evaluation of synthetic source models, J. Geophys. Res. Solid Earth, 120,
6431-6451, doi:10.1002/2015JB012272. \cr
}

