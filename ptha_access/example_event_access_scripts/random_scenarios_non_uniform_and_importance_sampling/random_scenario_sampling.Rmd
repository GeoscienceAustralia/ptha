# Randomly sample PTHA18 scenarios on a source-zone
---------------------------------------------------

The PTHA18 often includes thousands or tens-of-thousands of scenarios on a
source-zone. For some applications it is impractical to work with all
scenarios, but may be practical to work with a random sample of scenarios that
have similar statistical properties. 

For example, suppose we wish to conduct a probabilistic tsunami inundation
hazard assessment, which will require running computationally expensive
inundation models for every scenario. It may be impractical to do this for
every PTHA18 scenario, but feasible with a random sample containing hundreds or
thousands of scenarios. 

This tutorial examines a few approaches to randomly sample scenarios from a
given source-zone in a manner that is statistically consistent with the PTHA18.
This means that one can derive quantities of interest (such as the
maximum-stage exceedance-rate at a hazard point) from the random scenarios, and
the result will be arbitrarily close to the PTHA18 values IF the random sample
is sufficiently large. In all cases it is the users responsibility to determine
a sample size sufficient for accurate results, and that the sampling strategy
gives stable results for their application. In general the adequacy of
different methods and sample-sizes will vary case-by-case.

## Get the source-zone event data, and some maximum-stage data.
---------------------------------------------------------------

The first step is to get the scenario data for the source-zone of interest.
Here we choose to work with heterogeneous-slip scenarios from the
`kermadectonga2` source-zone. 
```{r startup}
# Get the scripts to access the PTHA18
ptha18 = new.env()
source('../../get_PTHA_results.R', local=ptha18, chdir=TRUE)
# Read all heterogeneous-slip scenario metadata (slip_type='stochastic' in PTHA18)
source_zone = 'kermadectonga2'
kt2_scenarios = ptha18$get_source_zone_events_data(source_zone,  slip_type='stochastic')
```

To illustrate how we can use the random scenarios, it is useful to have the
corresponding tsunami maximum-stage data at a point of interest. Herein we
choose a point just east of Tonga, which is over the `kermadectonga2`
source-zone (the calculations below could be equally applied to any other
point and source-zone).

```{r peakStageTonga}
event_peak_stage_at_refpoint = ptha18$get_peak_stage_at_point_for_each_event(
    target_point = c(185.1239, -21.0888), # Known location of PTHA18 hazard point
    slip_type='stochastic',
    all_source_names=source_zone)

# Convenient shorthand
event_peak_stage = event_peak_stage_at_refpoint$kermadectonga2$max_stage
```

## Random scenario sampling, stratified by magnitude
----------------------------------------------------

Our simplest random scenario sampling algorithm is termed `stratified-sampling` and proceeds as follows
* Group the scenarios by magnitude
* For each magnitude, sample a given number of scenarios with replacement, with
  the chance of sampling each scenario proportional to its conditional
  probability.

The function which does this only requires knowledge of the scenario
magnitudes, and the scenario rates. From these variables the function will
internally compute the scenario conditional probability for each unique
magnitude value (which ranges from 7.2, 7.3, ... 9.6, 9.7, 9.8 in PTHA18). 

We also need to specify the number of scenarios to sample for each magnitude. 
Herein a constant (12) is used, although in general it can vary with magnitude
(discussed later).

```{r randomSampling1}
# Convenient shorthand for the magnitudes and rates in the event table
event_Mw = kt2_scenarios$events$Mw 
event_rates = kt2_scenarios$events$rate_annual

# Make a reproducible random seed to make the code reproducible (this is optional)
set.seed(12)

# Make the random scenarios
random_scenarios_stratified = ptha18$randomly_sample_scenarios_by_Mw_and_rate(
    event_rates=event_rates,
    event_Mw=event_Mw,
    samples_per_Mw=function(Mw){ 12*(Mw < 9.65) } # Number of samples for each Mw
    )

```

The result is a `data.frame` containing the indices of the random scenarios
`inds`, their magnitudes, `mw`, as well as information on the scenario rates
that will be discussed further below.

```{r randomSampling1_B}
# Look at the first few rows
head(random_scenarios_stratified)
```
The columns are
* `inds` is the indices of the randomly selected scenarios. This corresponds to
  indices in the `event_Mw` and `event_rates` variables. Because herein these
  are simply columns of the event table, `inds` also also correspond to rows in
  `kt2_scenarios$events`.
* `mw` is the scenario magnitude. This is the same as
  `event_Mw[random_scenarios_stratified$inds]`
* `rate_with_this_mw` is the rate of ANY scenario with the same magnitude. This
  is the sum of `event_rates` for scenarios with the corresponding magnitude.
  Note THIS IS NOT THE RATE OF THE INDIVIDUAL SCENARIO!
* `importance_sampling_scenario_weights_basic` gives the scenarios weights
  determined by basic importance sampling. In this simple example they are
  constant in each magnitude bin, but later on when we define the
  `event_importance_weighted_sampling_probs` to bias the sampling toward
  scenarios of interest, the weights will be more complicated.
* `importance_sampling_scenario_weights_self_normalised` gives the scenarios
  weights determined by self-normalised importance sampling, which is an
  alternative to basic importance sampling.
* `importance_sampling_scenario_rates_basic` gives a nominal rate for each
  scenario, and is defined as `rate_with_this_mw` multiplied by
  `importance_sampling_scenario_weights_basic`. 
* `importance_sampling_scenario_rates_self_normalised` is another nominal rate
  for each scenario, defined as `rate_with_this_mw` multiplied by
  `importance_sampling_scenario_weights_self_normalised`.

In PTHA18 some earthquake magnitudes are impossible. In this case the scenario index will
take an `NA` value, as will various other variables. We see this at the end of the current
table, for magnitudes `9.7` and `9.8`.

```{r randomSampling1_C}
# Look at the last few rows - NA values for magnitudes that are "impossible" according to PTHA18 (rate_annual=0)
tail(random_scenarios_stratified)
```

Aside from the impossible magnitudes, we can confirm that we have 12 scenarios
per magnitude, as requested.
```{r randomSampling1_nsam}
table(random_scenarios_stratified$mw)
```

Some of the scenarios may be repeated - because we need to use random sampling
with replacement to get results that are statistically consistent with the
PTHA18.

### Approximating PTHA18 max-stage exceedance-rates with the random scenario subset
----------------------------------------------------------------------------------

What do we mean by saying the random scenarios are statistically consistent
with the PTHA18? The key point is that we can approximate the PTHA18 results
using a randomly chosen subset scenarios, which in some cases may contain many
fewer scenarios that the full PTHA18. This can be advantageous, for example if
we need to run new tsunami simulations for all the scenarios to get information
at our site of interest.

To demonstrate this we consider the tsunami max-stage exceedance-rates at the
aforementioned point offshore of Tonga. Any other location could similarly be
chosen. 

In the full PTHA, we can compute the max-stage exceedance rates at this point as:
```{r ptha18_tonga_point_exrates}
stage_seq = seq(0.1, 20, by=0.1)
stage_exrates_ptha18 = sapply(stage_seq, function(x) sum(event_rates*(event_peak_stage > x)))
```

The analogous calculation using only the random sample is:
```{r ptha18_tonga_point_random}
stage_exrates_rs_stratified = sapply(stage_seq, 
    function(x){
        sum(random_scenarios_stratified$importance_sampling_scenario_rates_basic * 
            (event_peak_stage[random_scenarios_stratified$inds] > x), na.rm=TRUE)
    })
```

The max-stage exceedance-rate curve derived from the random scenarios is
similar to the PTHA18 result, but there is some error due to the limited number
of samples (see figure below). As we increase the number of random scenarios
per magnitude, the accuracy will improve (on average) until the difference is
negligible. In this sense the random sample is statistically consistent with
the PTHA18.
```{r ptha18_tonga_point_plot1, fig.width=7, fig.height=5, warning=FALSE, echo=FALSE}
# Plot it
plot(stage_seq, stage_exrates_ptha18, log='xy', t='o', xlim=c(0.1, 10), ylim=c(1e-04, 1e-01),
     xlab='Max-stage (m)', ylab='Exceedance rate (events/year)', 
     main='PTHA18 stage-exrate curve vs random sample of scenarios')
points(stage_seq, stage_exrates_rs_stratified, t='l', col='red')
grid(col='orange')
legend('bottomleft', c('Original PTHA18 [desired result]', 'Random scenarios (stratified)'),
       col=c('black', 'red'), lty=c(1, 1), pch=c(1, NA))
```

*Note: Here and below we suppress the plotting code for readability. It can be found in the file
random_scenario_sampling.Rmd that was used to create this document.*

Below we do the same computation, but with more random scenario samples (120
per Mw, instead of 12). The figure shows this leads to improved agreement with
the PTHA18 exceedance-rates, as expected. On average the accuracy will improve
as the sample size is increased.
```{r ptha18_tonga_point_moresam}
# Make the random scenarios -- use 120 per magnitude, instead of 12
random_scenarios_stratified_many = ptha18$randomly_sample_scenarios_by_Mw_and_rate(
    event_rates=event_rates,
    event_Mw=event_Mw,
    samples_per_Mw=function(Mw){ 120 } # Number of samples for each Mw
    )

# Compute the max-stage exceedance-rates
stage_exrates_rs_stratified_many = sapply(stage_seq, 
    function(x){
        sum(random_scenarios_stratified_many$importance_sampling_scenario_rates_basic * 
            (event_peak_stage[random_scenarios_stratified_many$inds] > x), na.rm=TRUE)
    })
```

```{r ptha18_tonga_point_plot1_moresam, fig.width=7, fig.height=5, warning=FALSE, echo=FALSE}
plot(stage_seq, stage_exrates_ptha18, log='xy', t='o', xlim=c(0.1, 10), ylim=c(1e-04, 1e-01),
     xlab='Max-stage (m)', ylab='Exceedance rate (events/year)',
     main='Demonstration that using more random scenarios \n improves the accuracy')
points(stage_seq, stage_exrates_rs_stratified, t='l', col='red')
points(stage_seq, stage_exrates_rs_stratified_many, t='l', col='green')
grid(col='orange')
legend('bottomleft', c('Original PTHA18 [desired result]', 'Random scenarios (stratified)',
       'Random scenarios (stratified, 120 per Mw)'),
       col=c('black', 'red', 'green'), lty=c(1, 1, 1), pch=c(1, NA, NA))

```

In this example we are considering the max-stage exceedance-rates at a hazard
point, where we can easily use the full PTHA18 results. So for this example
there is no reason to use random sampling of scenarios. Why might we want to
use random scenarios? Suppose we were interested in the tsunami
inundation-depth exceedance rates at a nearby point. The PTHA18 does not
simulate inundation, and so we would need to run an inundation model for every
scenario. This is likely computationally prohibitive for the full set of PTHA18
scenarios, but it may be feasible for a random subset of scenarios. So long as
sufficiently many scenarios are sampled, it will also be accurate. 

There are also other techniques that may improve the accuracy of the results in
particular cases, without increasing the number of random scenarios used. The
idea is to use case-specific knowledge to bias the sampling toward scenarios of
interest, while accounting for this in the scenario rate calculation (to retain
consistency with PTHA18). Some of these techniques are explored below. Beware
their use requires judgement, and poor decisions may increase the error. In
contrast, simply increasing the number of scenarios will always lead to an
accuracy improvement on-average.


## Random scenario sampling, with more scenarios at magnitudes of interest
--------------------------------------------------------------------------

The stratified random sample that was defined above has many scenario with low
maximum-stage values, which are not of particular interest for this study. For
instance half of all the scenarios have max-stage less than 
`r round(median(event_peak_stage[random_scenarios_stratified$inds], na.rm=TRUE), 3)`
m, which seems too small to be of much interest in most tsunami hazard studies. 
```{r quantorig1}
quantile(event_peak_stage[random_scenarios_stratified$inds], seq(0, 1, len=5), na.rm=TRUE)
```
In practice we will be interested in larger waves. A potentially improved
strategy is to sample more scenarios at higher magnitudes, which are more
likely to generate larger waves. We can do this by adjusting `samples_per_Mw`.
Many approaches could be tried; below we illustrate 2 alternatives.

### Manually enforcing more sampling at higher magnitudes

Here we try increasing the number of scenarios at higher magnitudes. An ad-hoc choice
was made to varying the sampling effort linearly from 6 scenarios per bin at Mw 7.2, up
to 18 scenarios at Mw 9.6. This choice leads to the same number of scenarios as
the previous approach.

```{r scenarios_more_at_high_Mw}
# 7.2, 7.3, ... 9.6, 9.7, 9.8
unique_Mws = ptha18$unique_sorted_with_check_for_even_spacing(event_Mw)

# Linear varying from 6 (Mw 7.2) up to 18 (Mw 9.6)
sampling_effort_linear = approxfun(unique_Mws, 
    (unique_Mws < 9.65)*round( 6 + 12 * (unique_Mws - 7.15)/(9.65 - 7.15) ),
    method='constant')

# Make the random scenarios
random_scenarios_mw_weighted1 = ptha18$randomly_sample_scenarios_by_Mw_and_rate(
    event_rates=event_rates,
    event_Mw=event_Mw,
    samples_per_Mw=sampling_effort_linear 
    )

# Compute the max-stage exceedance-rates
stage_exrates_rs_mw_weighted1 = sapply(stage_seq, 
    function(x){
        sum(random_scenarios_mw_weighted1$importance_sampling_scenario_rates_basic * 
            (event_peak_stage[random_scenarios_mw_weighted1$inds] > x), na.rm=TRUE)
    })
```

In this particular case we do not really see improved agreement with the
max-stage vs exceedance-rate curve (compared with using 12 scenarios for each
magnitude bin). This could reflect that our magnitude-sampling method is not very
beneficial for this problem (at the end of this tutorial we check this). The
benefit of putting more sampling effort into higher magnitudes will vary
case-by-case; it is most useful when you have strong reason to think that low
magnitudes are unimportant for your study. A poor decision could decrease the
accuracy - for instance if lower magnitudes were actually important to the
hazard and were insufficiently sampled.

```{r ptha18_tonga_point_plot2, fig.width=7, fig.height=5, warning=FALSE, echo=FALSE}
# Plot it
plot(stage_seq, stage_exrates_ptha18, log='xy', t='o', xlim=c(0.1, 10), ylim=c(1e-04, 1e-01),
     xlab='Max-stage (m)', ylab='Exceedance rate (events/year)',
     main='PTHA18 stage-exrate curve vs random sample \n with sampling concentrated at higher Mw')
points(stage_seq, stage_exrates_rs_mw_weighted1, t='l', col='blue')
grid(col='orange')
legend('bottomleft', c('Original PTHA18 [desired result]', 'Sampling concentrated at higher Mw'),
       col=c('black', 'blue'), lty=c(1, 1), pch=c(1, NA))
```

### Semi-automatic calculation of the non-uniform sampling effort.

It is possible to calculate the theoretically optimum sampling effort in each magnitude bin
if we are given the site, scenario-frequency-model, and threshold stage. Although we are usually
interested in a range of sites and threshold stage values, the optimial solutions are a useful guide.

Here we compute the optimal sampling effort for a threshold stage of 2m
```{r optimalNonuniformSampling1}
TOTAL_SAMPLES = sum(12*(unique_Mws < 9.65)) # Number of samples used above

# stage_threshold = 2
non_uniform_samples_2 = ptha18$get_optimal_number_of_samples_per_Mw(
    event_Mw, event_rates, event_peak_stage, stage_threshold=2, 
    total_samples=TOTAL_SAMPLES)

# Look at the data structure
non_uniform_samples_2
```
The optimal sampling effort is contained in the column `Nsamples`. It is not a
whole number because the optimization technique treats the sampling effort as
continuous. Thus rounding will be required before using these values.

Here we do the same for a stage-threshold of 5m.
```{r optimalNonuniformSampling2}
# stage_threshold = 5
non_uniform_samples_5 = ptha18$get_optimal_number_of_samples_per_Mw(
    event_Mw, event_rates, event_peak_stage, stage_threshold=5, 
    total_samples=TOTAL_SAMPLES)
```

By visual inspection we see that the optimal solutions place most sampling
effort on intermediate and high magnitudes, with details depending on the stage threshold.

```{r plot_optimalNonUniformSampling1, fig.width=7, fig.height=5, warning=FALSE, echo=FALSE}

plot(non_uniform_samples_5$Mw, non_uniform_samples_5$Nsamples, t='o', col='red',
     xlab='Mw', ylab='Optimal # Samples', pch=19, lwd=2, 
     main='Optimal non-uniform sampling effort for different stage-thresholds')
points(non_uniform_samples_2$Mw, non_uniform_samples_2$Nsamples, t='o', 
       col='brown', pch=19, lwd=2)
abline(h=12, lwd=2, col='purple')
legend('topleft', c('Threshold = 5m', 'Threshold = 2m', 'Uniform sampling'),
       col=c('red', 'brown', 'purple'), lwd=c(2,2,2), pch=c(19, 19, NA))

```

In practice we can only choose one non-uniform sampling effort, which we would
like to be robust to different choices of the stage threshold, different sites,
and even different `event_rates` (if we intend to explore epistemic
uncertainties associated with source-frequency uncertainty). One way to do that is:

* Use uniform-sampling for 25% of the scenarios. This ensures that all magnitude-bins are represented.
* Use the average of the non-uniform results for the remaining 75% of scenarios. 

In practice the choice of stage thresholds should be varied according to the application at hand. 

```{r chosenNonUniformSampling}
# Uniform sampling up to magnitude 9.6
uniform_sampling_effort = 12 * (unique_Mws < 9.65) 

# Weight the optimal solutions with different stage-thresholds
average_nonuniform_sampling_effort = 
    0.5*(non_uniform_samples_2$Nsamples + non_uniform_samples_5$Nsamples)

# 25% uniform, 75% weighted non-uniform, rounded to integer values
chosen_sampling_effort_stratified = round(
    0.25*uniform_sampling_effort + 
    0.75*(average_nonuniform_sampling_effort))
```

At this point we can sample non-uniformly with the chosen sampling effort.

```{r scenarios_more_at_high_Mw2}
# Make the random scenarios
random_scenarios_mw_weighted2 = ptha18$randomly_sample_scenarios_by_Mw_and_rate(
    event_rates=event_rates,
    event_Mw=event_Mw,
    samples_per_Mw=approxfun(unique_Mws, chosen_sampling_effort_stratified, method='constant')
    )

# Compute the max-stage exceedance-rates
stage_exrates_rs_mw_weighted2 = sapply(stage_seq, 
    function(x){
        sum(random_scenarios_mw_weighted2$importance_sampling_scenario_rates_basic * 
            (event_peak_stage[random_scenarios_mw_weighted2$inds] > x), na.rm=TRUE)
    })
```

The results are qualitatively similar to those obtained using the manually-prescribed non-uniform
sampling effort. 

```{r ptha18_tonga_point_plot3, fig.width=7, fig.height=5, warning=FALSE, echo=FALSE}
# Plot it
plot(stage_seq, stage_exrates_ptha18, log='xy', t='o', xlim=c(0.1, 10), ylim=c(1e-04, 1e-01),
     xlab='Max-stage (m)', ylab='Exceedance rate (events/year)',
     main='PTHA18 stage-exrate curve vs random sample \n with sampling concentrated at higher Mw')
points(stage_seq, stage_exrates_rs_mw_weighted2, t='l', col='blue')
grid(col='orange')
legend('bottomleft', c('Original PTHA18 [desired result]', 'Sampling concentrated at higher Mw'),
       col=c('black', 'blue'), lty=c(1, 1), pch=c(1, NA))
```

### Summary of non-uniform sampling effort

Although non-uniform sampling of magnitude-bins can be useful, the improvements
tend to be modest. 

By concentrating sampling at higher magnitudes we sample larger max-stage
scenarios more often, as compared with the previous approach. However the
effect is not particularly strong, and there are still many scenarios with low
max-stage values.
```{r quantorig3}
# Ad-hoc choice of non-uniform sampling
quantile(event_peak_stage[random_scenarios_mw_weighted1$inds], seq(0, 1, len=5), na.rm=TRUE)
# Semi-optimal choice of non-uniform sampling
quantile(event_peak_stage[random_scenarios_mw_weighted2$inds], seq(0, 1, len=5), na.rm=TRUE)
```
The reason we still have many small max-stage scenarios is that the
`kermadectonga2` source-zone is very large, and the particular site of interest
(offshore of Tonga) is mainly affected by a small part of the source-zone. If
we are mostly interested in larger waves, then this seems like an inefficient
sampling approach for our site.

Typically much greater improvements can be obtained using the importance-sampling technique
outlined below.

## Random scenario sampling, using importance-sampling to emphasise higher max-stages
-------------------------------------------------------------------------------------

Here we show how the theory of importance-sampling can be used to more strongly
concentrate our random sample on scenarios that have higher maximum-stage
values. The sampling algorithm is:
* Group the scenarios by magnitude
* For each magnitude, sample a given number of scenarios with replacement, with
  the chance of sampling each scenario proportional to **a user-specified importance weighted sampling distribution**
  The latter step is where this method differs from regular sampling (unless
  `event_rates` is used as the user-specified distribution).
* The theory of importance-sampling provides a means to adjust the random
  scenario weights to correct for this preferential sampling. There are many
  statistical texts which cover importance-sampling, 
  [for instance see Chapter 9 of this freely available draft book by Art Owen](https://statweb.stanford.edu/~owen/mc/). 

In the example below we set the `event_importance_weighted_sampling_probs`
equal to the `event_rate` multiplied by the scenario's `event_peak_stage` at our site
offshore of Tonga. This means we prefer scenarios with higher max-stage at that
site, all else being equal. This might be a good choice if were studying
tsunami hazards nearby (e.g. in Tonga), but probably not if we were studying
the hazard far away (e.g. New Zealand). Many other choices could be made
depending on what is known about scenarios that are likely to be important for
your application. In this particular case we get much better agreement with the
PTHA18 max-stage exceedance-rate curve at our site while using 12 samples per magnitude bin.

```{r scenarios_stage_biased}
# Make the random scenarios -- 
random_scenarios_stage_weighted = ptha18$randomly_sample_scenarios_by_Mw_and_rate(
    event_rates=event_rates,
    event_Mw=event_Mw,
    event_importance_weighted_sampling_probs = (event_rates * event_peak_stage),
    samples_per_Mw=function(Mw){ 12*(Mw < 9.65) }
    )

# Compute the max-stage exceedance-rates
stage_exrates_rs_stage_weighted = sapply(stage_seq, 
    function(x){
        sum(random_scenarios_stage_weighted$importance_sampling_scenario_rates_basic * 
            (event_peak_stage[random_scenarios_stage_weighted$inds] > x), na.rm=TRUE)
    })

```

```{r ptha18_tonga_point_plot4, fig.width=7, fig.height=5, warning=FALSE, echo=FALSE}
# Plot it
plot(stage_seq, stage_exrates_ptha18, log='xy', t='o', xlim=c(0.1, 10), ylim=c(1e-04, 1e-01),
     xlab='Max-stage (m)', ylab='Exceedance rate (events/year)',
     main=paste0('PTHA18 stage-exrate curve vs random sample with max-stage \n',
                 'basic importance-sampling'))

points(stage_seq, stage_exrates_rs_stage_weighted, t='l', col='purple')
grid(col='orange')
legend('bottomleft', c('Original PTHA18 [desired result]', 'Importance based on event_peak_stage'),
       col=c('black', 'purple'), lty=c(1, 1), pch=c(1, NA))
```

In comparison to the previous approaches, we have more scenarios with high
max-stage values at our Tonga site, as expected because of how we used `event_peak_stage`
in the definition of the `event_importance_weighted_sampling_probs`.
```{r quantorig4}
quantile(event_peak_stage[random_scenarios_stage_weighted$inds], seq(0, 1, len=5), na.rm=TRUE)
```

### Combined importance-sampling and non-uniform sampling in magnitude-bins

We can also combine importance-sampling with non-uniform sampling in each magnitude bin. Here we
again draw on solutions for the optimal sampling-effort at a range of stage-values. The 
approach is very similar to that used previously for stratified-sampling, except we also
have to pass the `event_importance_weighted_sampling_probs` to the function. 


Here we compute the optimal sampling effort for a threshold stage of 2m, and 5m
```{r optimalNonuniformSamplingIS1}
TOTAL_SAMPLES = sum(12*(unique_Mws < 9.65)) # Number of samples used above

# stage_threshold = 2
non_uniform_samples_IS_2 = ptha18$get_optimal_number_of_samples_per_Mw(
    event_Mw, event_rates, event_peak_stage, stage_threshold=2, 
    event_importance_weighted_sampling_probs = (event_rates*event_peak_stage), # Different to above
    total_samples=TOTAL_SAMPLES)

# stage_threshold = 5
non_uniform_samples_IS_5 = ptha18$get_optimal_number_of_samples_per_Mw(
    event_Mw, event_rates, event_peak_stage, stage_threshold=5, 
    event_importance_weighted_sampling_probs = (event_rates*event_peak_stage), # Different to above
    total_samples=TOTAL_SAMPLES)

```

Next we determine the final sampling effort - again the logic follows the approach used above.

```{r chosenNonUniformSamplingIS}
# Uniform sampling up to magnitude 9.6
uniform_sampling_effort = 12 * (unique_Mws < 9.65) 

# Weight the optimal solutions with different stage-thresholds
average_nonuniform_sampling_effort_IS = 
    0.5*(non_uniform_samples_IS_2$Nsamples + non_uniform_samples_IS_5$Nsamples)

# 25% uniform, 75% weighted non-uniform, rounded to integer values
chosen_sampling_effort_IS = round(
    0.25*uniform_sampling_effort + 
    0.75*(average_nonuniform_sampling_effort_IS))
```

Finally we can generate random scenarios.

```{r scenarios_stage_biased2}
# Make the random scenarios -- 
random_scenarios_stage_mw_weighted = ptha18$randomly_sample_scenarios_by_Mw_and_rate(
    event_rates=event_rates,
    event_Mw=event_Mw,
    event_importance_weighted_sampling_probs = (event_rates * event_peak_stage),
    samples_per_Mw=approxfun(unique_Mws, chosen_sampling_effort_IS, method='constant')
    )

# Compute the max-stage exceedance-rates
stage_exrates_rs_stage_mw_weighted = sapply(stage_seq, 
    function(x){
        sum(random_scenarios_stage_mw_weighted$importance_sampling_scenario_rates_basic * 
            (event_peak_stage[random_scenarios_stage_mw_weighted$inds] > x), na.rm=TRUE)
    })

```

```{r ptha18_tonga_point_plot5, fig.width=7, fig.height=5, warning=FALSE, echo=FALSE}
# Plot it
plot(stage_seq, stage_exrates_ptha18, log='xy', t='o', xlim=c(0.1, 10), ylim=c(1e-04, 1e-01),
     xlab='Max-stage (m)', ylab='Exceedance rate (events/year)',
     main=paste0('PTHA18 stage-exrate curve vs random sample with max-stage \n',
                 'basic importance-sampling AND sampling concentrated at high Mw'))

points(stage_seq, stage_exrates_rs_stage_mw_weighted, t='l', col='purple')
grid(col='orange')
legend('topright', c('Original PTHA18 [desired result]', 'Importance based on event_peak_stage, non-uniform Mw'),
       col=c('black', 'purple'), lty=c(1, 1), pch=c(1, NA))
```

In comparison to the previous approaches, we have more scenarios with high
max-stage values at our Tonga site, as expected because of how we used `event_peak_stage`
in the definition of the `event_importance_weighted_sampling_probs`.
```{r quantorig5}
quantile(event_peak_stage[random_scenarios_stage_mw_weighted$inds], seq(0, 1, len=5), na.rm=TRUE)
```

### Summary of importance-sampling

Using importance sampling it becomes much easier to well represent scenarios
that have large waves near a site of interest. In practice we find the improvements
can be very substantial, as compared with stratified-sampling

Users should beware that importance sampling can backfire if the choice of
`event_importance_weighted_sampling_probs` is poor. We do not have a foolproof
method to set it, but expect the method here will work well in many cases. 

Users can check for any problems by studying the performance of their choice
under repeated sampling (at PTHA18 points) - a poor choice will lead to erratic
behaviour, as compared to simpler approaches.

